# generate pdf: M-x org-latex-export-to-pdf

#+LATEX_HEADER: \usepackage{7-sketches/my}

# https://en.wikipedia.org/wiki/List_of_mathematical_symbols_by_subject
# latexpreview / nolatexpreview C-c C-x C-l
# #+STARTUP: nolatexpreview
#+STARTUP: showeverything inlineimages latexpreview

Tai-Danae Bradley https://www.math3ma.com/categories/category-theory

* Abstract algebra of abstract functions
"The Arrows Count"; Category $C = (Obj, Hom, \circ, id)$
Category theory as a foundational framework of mathematics: the foundations of
category theory itself have to be clarified yet
- $Obj$ : Class of Objects: $A, B, C, ...$ e.g. Types / Propositions /
  Algebras / Logic Formulas
  An object exists in and depends upon an ambient category.
  An object is characterized by its morphisms going in and out of it.
  Objects are always characterized up to isomorphism (in the best cases, up to
  a unique isomorphism). E.g. there is no such thing as _the_ natural numbers.
  However, the concept of natural numbers exists.
- $Hom$ : Morphisms (arrows): f, g, h, ... e.g. Computation / Proofs / ??? /
  Implication between Logic Formulas
- $\circ$ : Morphism composition - associative function $(f \circ g) \circ h = f \circ (g \circ h)$
$Hom(A, B) \times Hom(B, C) \rightarrow Hom(A, C): g \circ f$ ; it's a partialy binary
operation on Mor(CAT::)
$(g \circ f)(x) = g(f(x))$
- $id$ : identity morphism on every object $A: id(A)$

- Category Theory is context rich and content poor

** Category - informal description
- A collection of arrows and morphism that can be composed if they are adjacent.
- A structure packing structures of the same type (same category) and structure
  preserving mappings between them.
- Directed Multigraph with Algebra of paths. Each finite path is associated with
  a unique arrow.
  -- Empty path: Identity
  -- One path: Morphism
  -- Two paths: Composition
  -- Three paths: Associativity law of composition.

Categories: mathematical contexts where constructions are possible.
Functors: Constructors
Natural Transformations: Comparison of constructions

*** Small Category: all objects and morphisms are sets

*** Locally Small Category: all objects and morphisms are sets
LSC "doesn't have too many morphisms"
$\forall A,B \in \mathcal{C}: Hom_\mathcal{C}(A, B)$ is a set.
(TODO arrow weight = price of calculation; preference for compositions)

*** Meaning of "Up to isomorphis" - any such things are isomorphic i.e.:
- structurally the same i.e.
- only formally different i.e.
- working via analogy i.e.
- $X$ is just a renamed version of $Y$

*** Meaning of "Commuting diagrams / It (i.e. a diagram) commutes"
no matter which way you go around you get the same thing

** Cartesian Closed Category
CCC is usefull in programming;
- Cartesian: has product $A \times B$ for any pair of objs $A$, $B$
- Closed: has exponential $B^A$ (functions from $A$ to $B$) for any pair of objs $A$, $B$
- 0-th power of an obj: has terminal obj \cdot (for all objects there exists a unique map $A \rightarrow \cdot$)

- multiplying by terminal obj \cdot gives back the original obj
- initial obj - dual to terminal obj \cdot; Top and Bottom objs i.e. any one-element
set (= singleton) is terminal DTTO for poset 1 is such an object that any other
obj is below it
- ? monoindal structure on objs ?

*** Locally Closed Cartesian Category
LCCC: for every obj $X$ sliced category is a CCC

** Bi-Cartesian Closed Category
BCCC: Algebra of Types can be made here
*** has coproduct for every pair of objs
*** has initial obj

** Universal Mapping Property (UMP): 'double' triangle of Product
Universal - for all
Consists of Initial and Terminal mapping (morphism)
Universal Construction - 3 steps (? the triangle ?):
1. Define a pattern:
```
         Z'  (Z' x A) ---+
         ⎢       ⎢        \
       h ⎢       ⎢id       \ g'
         ⎢       ⎢          \
    a=>b ↓       ↓           ↘
         Z   (Z x A) ------\rightarrow B
                 A      g

    g' = g ∘ (h x id)
```
2. Define ranking between matches
3. The best match is "our guy"

* A Crash Course in Category Theory
Bartosz Milewski on [youtube](https://www.youtube.com/watch?v=JH_Ou17_zyU) and
[twitter](https://twitter.com/@bartoszmilewski)
** Most important features of a category
*** Associative composability: $(x \circ y) \circ z = x \circ (y \circ z)$
*** Identity
Example in programming: Category of Types and Functions (set and functions
between sets)

*** Function
On sets / between sets
Pure: must be memoizable (lookup table)
Total: defined for all arguments
Partial: defined only for some arguments
Directionality (arrow "from \rightarrow to" i.e. functions are not symetric); n-to-1
relation
Inverse: not guaranteed to exist
$f: X \rightarrow Y$  - $X$ is Domain, $Y$ is Codomain
Image: A proper subset of a Codomain
Container: function itself can be regarded as a container. E.g. identity
function
Evaluation: it returns a value (when evaluated) i.e. data are represented as
values; i.e functions and data are the same
Function type: is an exponential which is a data type; (Exponential is like an
iterated product)

*** Morphisms / Mappings X \rightarrow Y
| Latin      | Greek / morphisms               | Meaning                                               | Functor  |
|------------+---------------------------------+-------------------------------------------------------+----------|
| surjective | epic / epi   \twoheadrightarrow | all $Ys$ are used                                     | Full     |
| injective  | monic / mono \rightarrowtail    | distinct $Xs$ $\rightarrow$ distinct $Ys$             | Faithful |
| bijective  | ? epi-mono?                     | exact pairing between $X, Y$                          |          |
| strict     | &nbsp;                          | surj $X \rightarrow Y$ but not bije $Y \rightarrow X$ |          |

Also:
```
Surjection  $|X| ≥ |Y|$  onto / $X$ at least as big $Y$ or bigger
Injection   $|X| ≤ |Y|$  one-to-one / $X$ at least as small $Y$ or smaller
Bijection   $|X| = |Y|$  mutually unambiguous, same size
Strict      $|X| < |Y|$  ? double usage of some $Ys$ ?, $X$ strictly smaller than $Y$
Epimorphism and Monomorphism are dual to each other
isomorphisms / isomorphic - "only formally different"
```

*** Pullback: type of a limit
$f: X \rightarrow Y$     $f$ is monomorphism ($X$ is at least as big as $Y$)
$id_Y: Y \rightarrow Y$
also: Pullback of a functor $I$ along a functor $F$ is a composite functor
(functor composition): $I \circ F$s

*** Pushout: type of a colimit
$f: X \rightarrow Y$     $f$ is epimorphism (all $Ys$ are used)
$id_X: X \rightarrow X$

*** Subobject of Object A
if $f: X \rightarrow Y$ is a monomorphism (i.e. an injection i.e. different $Xs \rightarrow$ different $Ys$ - don’t smush multiple elements into one, i.e. parallel arrows)
then it is isomorphic (i.e. only formally different) from $Y$.

I have a set of different monomorphisms to $Y$: \\
  $$S = {f1: A \rightarrow Y, f2: B \rightarrow Y}$$ \\
then $f1$, $f2$ are equivalent if there exists a in isomorphism $h: A \rightarrow B$ such that $f2 = h ∘ f1$ then $S$ is isomorphic to some subset of $Y$. i.e. a set of equivalent
morphisms mapping distinct to $Y$.

*** Functor: preserves structure between 2 categories
- Is a homomorphism by definition: it preserves structure between 2 categories
- In programming: total mapping of types; (total = all objs from the source are
  mapped)
- Constant functor: collapses all objs into 1 obj and all morphisms into an
  identity
- Intuitive understanding: (endo) functor is a container - i.e. list contains
values (Comonad is a container that already comes prefilled with many values and
with an access point to one particular value. E.g. hidden params (for hidden
param propagation it's better to use comonad than monad), history, neighbourhood
etc.)
- Endofunctor $[C,C]$: $A$ ftor that maps a category to itself
- Lifting: (= applying functor) transforms a function into a corresponding
  function within another (usually more general) setting

```
                Ff
          Fa ------\rightarrow Fb
           ↑          ↑
           |    f     |
           a ------\rightarrow b
```
- Covariant: Same directions in src and dst Category
$G f :: (a \rightarrow b) \rightarrow (G a \rightarrow G b)$
- Contravariant: Reverse directions in src and dst Category
$G f :: (a \rightarrow b) \rightarrow (G b \rightarrow G a)$
- Bifunctor: e.g a Product - it takes 2 objs and produces 3rd obj, but it
also takes two morphisms and produces 3rd morphism which is a product of
these two morphisms $C \times D \rightarrow E$
- List: $List(α) = Nil | Const α (List α)$ - most intuitive(?) functor
example It's also a type constructor: takes a type α and creates a list of α

Sum (+) and Product (\times) are algebraic data types (Algebra on Types):
List(α) = Nil | Const α (List α) ~ L(α) = 1 + α \times L(α) => .. => L(α) = 1 / (1 -
α) = 1 + α + α \times α + α \times α \times α + ...

Inlining and refactoring are the opposite.

*** Fibre: points mapped to the same value
invertibility: function to fibre

*** Natural Transformation: a way of/for comparing functors
- maps Morphism(s) to commuting diagram(s) (naturality squares). i.e.
comorphism: replacing a square of (complex) relations with a single morphism
- picks a morphish between two Objs; Picking 1 morphishm from a Homset
- Components of NaT
- Composing Ftor acting on an Obj with a Ftor acting on a Morphishm: $αb \circ Ff$
- Every polymorphic functions is a NaT: it is defined for every single type
i.e. multiplication (Product) of all Objs in a Category. The same goes for
the dual - the Sum.
- Functor is a container, NaT repackages the container
- Naturality condition i.e. the Naturality Square: $Gf ∘ αa = αb ∘ Ff$

**** Compositons of Natural Transformations
See https://math.vanderbilt.edu/dept/conf/tacl2013/coursematerials/SelingerTACL20132.pdf
E.g. NaT compositons is scala: https://gist.github.com/Mzk-Levi/752d1e0f2f7f30cd3bda
Legend:
$A$ - an Obj in the Category $\mathcal{C}$
$(...)A$ / $[...]A$ - an A-component of the NaT (...) / [...]
$αA$ / $βA$ - an A-component of the NaT α / β
$αFA$ - an FA-component of the NaT α
$βGA$ / $βFA$ - GA/FA-component of the NaT β

***** Verical Compositon of NaTs:
If $α:F \rightarrow G$ and $β:G \rightarrow H$ are natural transformations, then so is $β • α : F \rightarrow H$.
Is it defined by:
$(β • α)A = βA \circ αA : FA \rightarrow HA$
A - an Obj in the Category C
(...)A - an A-component of the NaT (...)

- is associative and has an id, and allows one to consider the collection
of all functors C \rightarrow D itself as a category.

***** Right Whiskering
If $F, G : C \rightarrow D$ and $H : D \rightarrow E$ are Ftors, and if $α : F \rightarrow G$ is a NaT, the right
whiskering
$H \circ α : H \circ F \rightarrow H \circ G$
is defined as $(H \circ α)A : H(FA) \rightarrow H(GA)$ by $(H \circ α)A = H(αA)$

***** Left Whiskering
If $F : C \rightarrow D$ and $G, H : D \rightarrow E$ are Ftors, and if $α : G \rightarrow H$ is a NaT, the left
whiskering
$α \circ F : G \circ F \rightarrow H \circ F$
is defined as $(α \circ F)A : G(FA) \rightarrow H(FA)$ by $(α \circ F)A = αFA$

***** Horizontal Compositon of NaTs:
If $F, G : C \rightarrow D$ and $H, K : D \rightarrow E$ are Ftors, and if $α : F \rightarrow G$ and β$ : H \rightarrow K$
are NaTs, the horizontal composition:
$β \circ α : H \circ F \rightarrow K \circ G$
can be defined in two different ways:
- Right whiskering followed by left whiskering:
$β \circ α = (β \circ G) • (H \circ α)$
- Left whiskering followed by right whiskering:
$β \circ α = (K \circ α) • (β \circ F)$

The two definitions coincide, because
$[(β \circ G) • (H \circ α)]A = βGA \circ H(α A)$, and
$[(K \circ α) • (β \circ F)]A = K(α A) \circ βFA$

- is associative with an id, and the id coincides with that for vertical
composition.

** Yoneda perspective, embeding and lemma
*** Yoneda Perspective
An object is completely determined by its relationships to other objects

*** Yoneda Embedding https://youtu.be/JH_Ou17_zyU?t=1h8m9s
Idea: replace content of an object (picked i.e. fixed) by all arrows ending in
this object.
It's content and properties.
Set of Arrow from every possible Obj $X$ to the Obj $A$

Mapping from an Obj $X$ to the Set of Arrows $X \rightarrow A$:
1. for every Obj $A$ get a different functor $F: C \rightarrow Set$
2. then vary the Obj $A$:

*** Yoneda Lemma
Idea: Natural transformation and functor (i.e. Container) can replace each other
$[C,Set](C(a,-), F) \simeq F a$   also: $[C,Set](C(a,-), C(b,-)) \simeq C(b,a)$
- Description of integration over a special Ftor (i.e. Hom Functor)

$a$ - some arbitrary Obj of C
$F$ - some arbitrary Ftor acting on the Obj a
$\simeq$ - "naturally isomorphic" (i.e. a NaT exists such that its components are
all invertible isomorphisms)

Hom functors - Intuition:
- Serve for the same purposes as Free Monoids

It's enough to define this NaT on one Obj (i.e. set C(a,a)) and moreover
it's enough to define it on one Point in this Set i.e. the Identity on Obj a.
The rest of the NaT is transported from this Point.
```
 (                     ) \simeq F a
           ⎜                ⎜
           ⎜                +-- Container of the Obj a (i.e. the data structure)
           +------------------- Polymorphic higher order Function

 (\forall x : (a \rightarrow x) \rightarrow F x) \simeq F a
           ⎜    ⎜  ⎜      ⎜
           ⎜    ⎜  ⎜      +--- Container of the Obj a (i.e data structure)
           ⎜    ⎜  +---------- Functor
           ⎜    +------------- NaT i.e. Polymorphic Higher Order Function
           +------------------ ...
```

*** Khan Extentions: the next abstraction level
*** Adjunctions: weakening of "equality" of Categories
"inverse" is defined only for functions not functors
e.g. Currying: from a Pair to Function type

*** Adjointness: constructing / generating principle
- Adjunctions/Adjoins are monads ???
examples:
- product is left adjoint to exponential: $(-) x A ⊣ (-)^A$
- left adjointness of sum (coproduct), pairing and product: $Σ ⊣ ∆ ⊣ Π$
induction, recursion, Natural Numbers (inductively defined), Lists, ...
conjunction, disjunction, True, False, Exponentiation
Quantifiers: \forall Every, \exists Exists; Σ Sigma, Π Pi

*** Abstraction: the non-invertibility
- from all properties (i.e. all points of a fibre) I'm interested only in one
- e.g. I'm not interested in what was the exact input value of a function,
I'm interested only if it was an even or odd value

*** Modeling: mapping / injecting
HomSet: HomC(A,B) = {f: A \rightarrow B}
- Set of all morphisms A \rightarrow B in a category C. Objs of C don't need to be sets.
- A collection of two monoids A,B (The identity on an object is its monoidal
  operation) with a set of compatible transitions between them.

External vs. Internal Homset

*** Free Monoid: has a unique mapping to every other monoid
A list of accumulated vals

*** HomFunctor: Functor to category of Sets
Has a NaT to every other functor. This NaT is not unique but limited
Reader functor in Haskell

*** Covariant functor: Hom(A,–) : C \rightarrow Set
$F f :: (a \rightarrow b) \rightarrow (F a \rightarrow F b)$ - same directions in src and dst Category
Hom(A,–) maps each object X in C to the set of morphisms, Hom(A, X)
Hom(A,–) maps each morphism f : X \rightarrow Y to the function
Hom(A, f) : Hom(A, X) \rightarrow Hom(A, Y) given by

*** Contravariant functor: Hom(–,B) : C-op \rightarrow Set
$F f :: (a \rightarrow b) \rightarrow (F b \rightarrow F a)$ - Reverse directions in src and dst Category
Hom(–,B) maps each object X in C to the set of morphisms, Hom(X, B)
Hom(–,B) maps each morphism h : X \rightarrow Y to the function
Hom(h, B) : Hom(Y, B) \rightarrow Hom(X, B) given by

*** Representable Functor F: C \rightarrow Set is naturally isomorphic to HomC(A,-) for some object A of C
Represents:
- objs of C as sets
- morphisms of C as morphisms between sets.
i.e. functions "tabulate", "index" can be created; mapping of function to a data-type

Functors as representations (Lawvere):
Think of a functor $F: C \rightarrow D$ as giving a picture, or "representation", of $C$ in $D$.

Following Lawvere, logicians often call the categoryCa ‘theory’, and call the
functor $F : C \rightarrow D$ a "model" of this theory.

(TODO see Bartosz's intuition about functors in the "Programming with Categories" videos)

For any fix obj $A \in C$, we have a $HomC(A,-)$ such that we have a mapping
$HomC(A,X) \rightarrow HomC(A, Y)$ when there is a morphism $X \rightarrow Y$. E.g.:
The forgetful functor Grp \rightarrow Set on the category of groups $(G, *, e)$ is
represented by $(Z, 1)$.
The forgetful functor Ring \rightarrow Set on the category of rings is represented by
$(Z[x], x)$, the polynomial ring in one variable with integer coefficients.
The forgetful functor Vect \rightarrow Set on the category of real vector spaces is
represented by $(R, 1)$.
The forgetful functor Top \rightarrow Set on the category of topological spaces is
represented by any singleton topological space with its unique e

*** Homomorphism: structure-preserving mapping between 2 algebraic structures
$f(m * n) = f(m) * f(n)$
Individual monoids themselves give category
Monoids with homomorphisms give category

*** Kleisli category
Monad: return: a \rightarrow m a; bind: m a \rightarrow (a \rightarrow m b) \rightarrow m b
You can operate on IO Monad
You can't extract anything from IO Monad (it's lost)
Monoind in Category of Endofunctors
Comonad: (w a \rightarrow b) \rightarrow (w b \rightarrow c) \rightarrow (w a \rightarrow c)
You can extract from IO Monad
You can't put anything to IO Monad

*** Indexed Monad: IxMonad: ibind: m i j a \rightarrow (a \rightarrow m j k b) \rightarrow m i k b
state composition
Session Types, Dependent Types, Dependent State Types

*** Curry-Howard-Lambek correspondence: Intuitionistic Logic \leftarrowrightarrow Type Theory \leftarrowrightarrow Category Theory:
Function A \rightarrow B is a proof of logical implication A => B
Direct relationship between computer programs and mathematical proofs; from 1940-ties
Link between Computation and Logic;
Proofs-as-programs and propositions- or formulae-as-types interpretation;
Proofs (= Programs) can be executed;
Typed lambda calculi derived from the Curry–Howard-Lambek paradigm led to software like Coq;
Curry-Howard-Lambek correspondence might lead to unification between mathematical logic and foundational computer science;
Popular approach: use monads to segregate provably terminating from potentially non-terminating code
Alternative: P or Q - "doesn't really matter what which one it is as long as at least one works"

| INTUITIONISTIC (Constructive) LOGIC            | TYPE THEORY - Functional Programming                                 | CATEGORY THEORY |
| Howard                                         | Curry                                                                | Lambek          |
|------------------------------------------------|----------------------------------------------------------------------|-----------------|
| Proposition of some type - (something is true) | Type (contract - a set of values that passes the contract)           |                 |
| Proof of some type                             | Term (A program - guarded fn)                                        |                 |
| Normalisation (Proof equality)                 | Computation (substitute variable with value)                         |                 |
|                                                |                                                                      |                 |
| P implies Q: P \rightarrow Q (i.e. there exists one)    | paricular fn of fn of P-contract to guarded fn of Q-contract: P \rightarrow Q | Exponential     |
| \rightarrow is constructive implication                 | \rightarrow is function from-to                                               |                 |
| false      \rightarrow false (implies)                  | {}       \rightarrow  {}  no values (empty set); contract cannot be satisfied |                 |
| false      \rightarrow true                             | {}       \rightarrow  {.} (one element set)                                   |                 |
| true       \rightarrow true                             | {.}      \rightarrow  {.} (identity function)                                 |                 |
| true  (not \rightarrow) false (does not imply)          | {.} (not \rightarrow) {}                                                      |                 |
| Conjunction - and: P ⋀ Q                       | Pair (P, Q)     (proof-of-P, proof-of-Q)                             | Product         |
| Alternative - or: P ⋁ Q                        | Union of (different) proofs P, Q                                     | Sum             |


** Correspondance of type habitation and proposition
inhabited - has elems / members
"Either a b" is inhabited if either a or b is inhabited (at least one of them is true / provable)

Curry: ((a,b) \rightarrow c) \rightarrow (a \rightarrow (b \rightarrow c))
Uncurry: (a \rightarrow (b \rightarrow c)) \rightarrow ((a,b) \rightarrow c)

Eval: a function of two args / a pair
$((a => b), a) \rightarrow b$ this is modus-ponens in logic $(a => b) ∧ a \rightarrow b$

| True proposition | False proposition | Conjunction $a ∧ b$              | Disjunction $a ∨ b$           | Implication $a => b$            |
| Unit-type        | Void-type         | Pair $(a,b)$                     | Either $a$ or $b$             | Function type $a \rightarrow b$ |
| sinhabited       | not inhabited     |                                  |                               |                                 |
| Terminal obj     | Initial obj       | Categorical product $a \times b$ | Categorical coproduct $a ⎥ b$ | Exponential obj $b^a$           |


0 - void type - ?
1 - unit type - 0th-power: terminal obj
2 - bool type (two possible values): 1st-power: the obj itself
3 - int type - 2nd-power: product
4 - real type (if continuum hypothesis holds :-)
5 - ? type

JavaScript & Category Theory: Category == Contracts + Functions guarded by contracts

** Set vs. Category theory comparision
| Set theory                  | Category theory                                          | JavaScript                     |
|-----------------------------|----------------------------------------------------------|--------------------------------|
| membership relation         | -                                                        |                                |
| elements                    | objects                                                  | contracts                      |
| sets                        | categories                                               |                                |
| -                           | morphisms (structure-preserving mapping between objects) | functions guarded by contracts |
| functions                   | functors  (maps between categories)                      |                                |
| equations between elements  | isomorphisms between objects                             |                                |
| equations between sets      | equivalences between categories                          |                                |
| equations between functions | natural transformations (maps between functors)          |                                |

Categorification: process of weakening structure, weakening equalities down to
natural isomorphisms and then adding-in rules that these natural isomorphisms
have to follow (so it behaves well)
Counting number of elements in sets is decategorification; from category we get
set or from set we get a number
Monoid homomorphisms: a function between the sets of monoid elements that
preserved the monoid structure
Monoidal functors: a functor between categories that preserves the monoidal
structure (should preserve multiplication) from functor(prodn([x, y, ..])) to
prodn([functor(x), functor(y), ..])
Monoidal monad:       ???

Functor:
"forget the indexing (domain functor)"

*** Contract = Object
*** Product: examples:
Objects   - numbers
Morphisms - functions 'less/greater or equal than'

*** Isomorphism (bijection when f is a function on set / sets):
\forall f: X \rightarrow Y there \exists g: Y \rightarrow X such that g ∘ f = idX and f ∘ g = idY
where idX, idY are identity morphisms on X, Y.
IOW f is invertible and g is the inverse of f

** Category theory - Modeling (new vocabulary)
| hierarchies                | partial orders     |
| symmetries                 | group elements ?   |
| data models                | categories         |
| agent actions              | monoid actions     |
| local-to-global principles | sheaves (lanovica) |
| self-similarity            | operads            |
| context                    | monads             |

** olog = ontology log
Different branches of mathematics can be formalized
into categories. These categories can then be connected together by functors. And the
sense in which these functors provide powerful communication of ideas is that facts and
theorems proven in one category can be transferred through a connecting functor to
yield proofs of an analogous theorem in another category. A functor is like a conductor
of mathematical truth.

* Ultimatelly the human lang to talk about ideas is the lang of math.
Formulas, Multiplication, stupid mistakes in deriving, simplification etc.
CT looks nicer: no numbers, it's about ideas

* Semantics: TODO rewatch Bartosz Milewski
Designing computer language - Semantics must be provided; done by providing operational semantics
Programming - understanding the meaning i.e. semantics: what does it mean (+ 1 2)
None of the main prog. languages have (operational semantics) only partially provided.
** Operational semantics: "if state === stateX then state = stateY"
"How it executes"; reduction relation: $e1 \rightarrow e2$
for computers: local, progress oriented
Mind machine: We keep on imagining the if-then-else steps.
This is bad way - computers are much better at it.

** Denotational semantics
Denotational: mapping into mathematics; interpretation of terms: $⟦e⟧ = ?$
e.g.: $⟦ v : τ ⊢ v : τ ⟧ = idτ $ - i.e. the meaning of $⟦...⟧$ is
an identity on $τ$ i.e. an access to variable $v$
TODO [klipse "(identity 1)"]
programs can be translated to math - math is a better lang for humans
"Programm has a meaning i.e. it's a piece of math: operation, declaration, definition"

** Mathematical semantics: Functional Programming

* HoTT: functions, types and proofs
** A type it's about its construction
*** A type consists of
Constructor: how to create an element of this type
Induction: how to use elements of this type
*** It's an abstraction about a set of vals; it's about "what" (function declaration)
For mathematicians Set Theory is a low level assembly lang of maths - recenty started to be avoided:
*** Difference between a type and a set: https://youtu.be/ba4E6EMagj0?t=283
A type provides tools for creation of funtions using this type. A set
doesn't provide such tools. I.e. a type has more stucture than a set.
** A (pure) function: mapping between sets
It's about "how" (function body) - ? contrary of abstraction ?

** A proof is an object to be constructed analogically as an object of a certain type
$x = y$ is an equality-type. To proove this equality means to create an
object of the equality-type
*** $x \equiv y$ definitional equality - does not correspond to a type
x and y can constructed from the definition of their type using the
type-constructor. I.e. they're basically constructed "the same way"
*** $x = y$ propositional equality
if x and y are definitionally equal then an associated propositionally equal
element can be deduced from this.
*** Theorem
- for every function f there is a function $ap-f: (x = y) \rightarrow (f(x) = f(y))$
- from (an element of the type) $(x = y)$ the $ap-f$ is going to construct
(an element of the type) $(f(x) = f(y))$
- in logic the funtion ap-f corresponds to an implication. In generall in the
type theory a funtion is nothing else than an implication
*** Classical logic and type theory correspondence
Type theory searches for construction of a type-dependent function f (or z) ...:
| classical logic              | type theory            | notation                   |
| \foralln\forallm (n+m = m+n) | f:(n,m) \rightarrow (n+m = m+n) | f: Π n:ℕ Π m:ℕ (n+m = m+n) |
| \existsn\forallm (n+m = m)   |                        | z: Σ n:ℕ Π m:ℕ (n+m = m)   |
|                              |                        |                            |

** Siplified Categorical view of functions and types:
*** Functions: arrows between objs
*** Types: objects whose properties are defined by arrows
*** Composition, associativity, identity: see Group-like structures
Composition: "this-fn after that-fn"
No deeper specification of what the funtions and objects are
Mapping between CT and FP:

* Views \rightarrow Change of perspective
** Set-theoretical: props of sets defined by elems of sets
** Categorical: Shrink the set to a point "I can't look at the structure of a set"
Describe different kinds of sets by their interraction with other sets i.e. by arrows.
Tell me who your friends are and I tell you who you are

Phenomenons of Introduction and Elimination

Data types:
* Void (empty set): we don't know that it has no elems; describe/define the props
using arrows, i.e. saying something universal; universal property UP
initial obj: Univ prop: unique(1.) arrow to every(2.) single other obj
(corresponds to falsehood in logic)
** intro: can't be constructed (can't construct a fn returning an elem of empty set)
??? Identity fn on void ???
** elim: Void \rightarrow A (arrow from; polymorphic fn - works for any type)

* Unit (one-elem set): univ prop: terminal obj (opposite i.e. dual to init-obj); Duality - invert the arrows and you get something for free
** intro: A \rightarrow Unit (fn: just ignore the fn input)
** elim: Unit \rightarrow A (fn: pick one elem of a type i.e. set; some sort of "cheating" - instead of an elem we pick a morphism)

* Cartesian(?) Product
- https://youtu.be/8AGWTWVOJ74?t=1329
  "I have one thing, I have another thing and now I have two things"
- set of all pairs: UP (universal construction) - best product triangle: for all
other types there's the unique arrow projections: f: C \rightarrow A, g: C \rightarrow B
- tuple (pair aka record) is better than tripple ??? loop-over-all-types: for each of
all possible types: 38:20
** intro: A \rightarrow B \rightarrow (A,B) tupple
** elim: (A,B) \rightarrow A, (A,B) \rightarrow B

* Relation
A subset of a Cartesian Product; doesn't have a directionality; n-to-n relation

* Sum type (dual to product - coproduct)
** intro: A \rightarrow either A or B, B \rightarrow either A or B
** elim: case e of: left a \rightarrow f a, right b \rightarrow f b
** in functional programming - tagged unions

* Monoidal Cat (objs, arrows, prods)
looks kinda like multiplication / addition
Algebra of types ...

* Functor
Structure preserving mapping between Cats (objs to objs, fns to fns): i.e. if
there's an arrow A \rightarrow B, then there must be arrow F(A) \rightarrow F(B)
May collapse things, preserves unit obj and composition

** Endofunctor
mapping from the same Cat to the same Cat. Endo ~ inside, "Endoscopy"
Category of Endofunctors: Cat of ftors from C to C [C,C]

* ? Functor Category
Pick two Categories C, D - functors from C to D form a Functor Category [C,D]:
Objects: functors
Morphisms: natural transformations between functor

* Adjunction
A pair of ftors F, G: F is adjunct (but not inverse) to G
Obj in a Cat of Types such that: For every A, B there is a set of arrows from
A to B. This obj is called function-type. It can be defined by an adjuction of
two endofunctors

** It's more interesting if F, G are not an inverse of each other
** F left adjoing to G:
*** left side: prepare an argument for some function using functor F
*** right side: modifying the output of some function using functor G
F A === (A, C)   ftor F acts on A and creates a pair type (A, C)
G B === C \rightarrow B   ftor G acts on B and creates a function type from C to B

Currying arrises from an Adjunction:
(A, C) \rightarrow B is isomorphic (i.e. equivalent) to A \rightarrow (C \rightarrow B)

If you have a pairing (product) and if you have such an adjunction in your Cat
then you are able to define a function type (en exponential).

A Cat with such pairing and adjunction is called cartesian closed (i.e. this Cat
has a function type)

** function intro: lambda
** function elim: eval

* Natural transformations
NaTs: Polymorphic functions: mapping between ftors. See a
[picture](https://youtu.be/JH_Ou17_zyU?t=1h6m23s)
* Polymorphic function
a function for every single type i.e. multiplication
(Product) of all obj in a category. Also the dual - the Sum
* Categorical End (i.e. Product) and CoEnd (i.e. CoProduct i.e. Sum)
notation is the integral sign

* Monadic return-function
universally polymorphic function - works for any type
  https://www.youtube.com/watch?v=CfoaY2Ybf8M&t=7m

Generalisation of everything. They sub-sume everything else, like adjuctions at a higher level

Limits, Colimits, Monads Adjunctions can be redefined as Khan Extentions

Intuition of Khan Extentions is difficult - they are more abstract than monads
Adjunction between a Product and a Function Type is Currying

Product generalisation: Tensor Product in a monoidal category

There are many generalizations. If you get rid of the idea of having distinct
objects you get a monoid. If you get rid of the idea of composition/identity
being always defined you get a paracategory. If you generalize composition as in
"many morphisms can be composed together" you get an operad. If you get rid of
the idea of composition/identity laws having to hold with equality you get
higher categories.

* Category theory - definition dependencies
Based on definitions in The Joy of Cats.
https://www.johndcook.com/blog/category_theory/

* N-Categories
\href{https://youtu.be/6bnU7_6CNa0}{Tom Leinster: "An introduction to n-categories"}

\href{https://youtu.be/6bnU7_6CNa0?t=3369}{56:09} \\
$-2$ -Category: There's only one. (Tom provides no explanation in the video.) \\
$-1$ -Category: Boolean truth values, i.e. there are two $-1$ categories: $True$, $False$. \\
$+0$ -Category: set \\
$+1$ -Category: ...
