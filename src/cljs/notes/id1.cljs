(ns notes.id1
  (:require
   [notes.collapsible :refer [e] :as collapse]
   [clojure.string :refer [join]]
   ))

;; [e ""]
(def ui
  [collapse/ui
   {:id "id1"
    :title "* A Crash Course in Category Theory - Bartosz Milewski https://www.youtube.com/watch?v=JH_Ou17_zyU"
    :content
    [:div
     [:div "  https://twitter.com/@bartoszmilewski : Computer Science, Haskell, C++. PhD in Quantum Physics"]
     [:div " "]
     [:div "  Most important features of a category: ?, Composability, Identity"]
     [:div "  Example in programming: Category of Types and Functions (set and functions between sets)"]
     [:div "*** Designing computer language:"]
     [:div "    Semantics must be provided; done by providing operational semantics"]
     [:div "    None of  the main prog. languages have (operational semantics) only partially provided;"]
     [:div "    Two ways of defining semantics:"]
     [:div "    - Operational: \"How it executes\"; reduction relation: " [e "e1 → e2"]]
     [:div "    - Denotational: mapping into mathematics; interpretation of terms: " [e "⟦e⟧ = ?"]]
     [:div "      e.g.: " [e "⟦ v : τ  ⊢  v : τ ⟧ = idτ "] "- i.e. the meaning of " [e "⟦...⟧"] " is an identity on " [e "τ"] " i.e. an access to variable " [e "v"]]
     [:div " "]
     [:div "*** Cartesian Product CP: set of all pairs"]
     [:div "    Relation: A subset of CP; doesn't have a directionality; n-to-n relation"]
     [:div "*** Functions: (Sets and functions between sets)"]
     [:div "    Pure: must be memoizable (lookup table)"]
     [:div "    Total: defined for all arguments"]
     [:div "    Partial: defined only for some arguments"]
     [:div "    Directionality (arrow from→to i.e. functions are not symetric); n-to-1 relation"]
     [:div "    - Inverse of function is not guaranteed to exist"]
     [:div " "]
     [:div "    Domain, Codomain, Image"]
     [:div "*** Morphisms:"]
     [:div "    | Latin      | Greek                | Meaning                   | Functor  |"]
     [:div "    |------------+----------------------+---------------------------+----------|"]
     [:div "    | injective  | monic / monomorphism | distinct Xs → distinct Ys | Faithful |"]
     [:div "    | surjective | epic / epimorphism   | all Ys are used           | Full     |"]
     [:div " "]
     [:div "*** Functor:"]
     [:div "    - preserves structure between 2 categories, i.e. a homomorphism by definition"]
     [:div "    - in programming: total mapping of types; (total = all objs from the source are mapped)"]
     [:div "    - Constant functor: collapses all objs into 1 obj and all morphisms into an identity"]
     [:div "    - Intuitive understanding: (endo) functor is a container - i.e. list contains values"]
     [:div "      (Comonad is a container that already comes prefilled with many values and"]
     [:div "      with an access point to one particular value. E.g. hidden params (for"]
     [:div "      hidden param propagation it's better to use comonad than monad), history,"]
     [:div "      neighbourhood etc.)"]
     [:div "    - function itself can be regarded as a container. E.g. identity function;"]
     [:div "      functions (when evaluated) return value i.e. data are represented as values"]
     [:div "      functions and data are the same"]
     [:div "      function type is an exponential which is a data type; (Exponential is like an interated product)"]
     [:div "    - Endofunctor [C,C]: A ftor that maps a category to itself"]
     [:div " "]
     [:div
      [e
       (join
        "\n"
        [
         "  | Covariant Functor                       | Contravariant Functor                      |"
         "  |-----------------------------------------+--------------------------------------------|"
         "  | G f :: (a → b) → (G a → G b)            | G f :: (a → b) → (G b → G a)               |"
         "  | Same directions in src and dst Category | Reverse directions in src and dst Category |"
         ]
        )
       (join
        "\n"
        [
         ;; "\\def\\arraystretch{1.2}"
         ;; "\\boxed"
         "\\begin{array}{cc}"
         "| & \\text{Covariant Functor}                       & | & \\text{Contravariant Functor}                      & | \\\\"
         "| & G f :: (a → b) → (G a → G b)                    & | & G f :: (a → b) → (G b → G a)                       & | \\\\"
         "| & \\text{Same directions in src and dst Category} & | & \\text{Reverse directions in src and dst Category} & |"
         "\\end{array}"
         ])]]
     [:div " "]
     [:div "*** Bifunctor: " [e "C × D → E"]]
     [:div "    Product is a bifunctor, i.e. it takes 2 objs and produces 3rd obj, but it"]
     [:div "    also takes two morphisms and produces 3rd morphism which is a product of"]
     [:div "    these two morphisms"]
     [:div "**** List: " [e "List(α) = Nil | Const α (List α)"]]
     [:div "    - most intuitive example of a Ftor"]
     [:div "    - type constructor: takes a type α and creates a list of α"]
     [:div " "]
     [:div "    Sum (+) and Product (*) are algebraic data types (Algebra on Types):"]
     [:div "    " [e "List(α) = Nil | Const α (List α) ~ L(α) = 1 + α * L(α) ⇒ .. ⇒ L(α) = 1 / (1 - α) = 1 + α + α*α + α*α*α + ..."]]
     [:div " "]
     [:div "    Is Product a Ftor?"]
     [:div " "]
     [:div "    Inlining and refactoring are the opposite.** Fibre: a buch of points mapped"]
     [:div "    to the same value; invertibility of a function to a fibre"]
     [:div " "]
     [:div "    Lifting (= applying functor):"]
     [:div "                F f"]
     [:div "          F a -----→ F b"]
     [:div "           ↑           ↑"]
     [:div "           |     f     |"]
     [:div "           a -------→ b"]
     [:div " "]
     [:div "*** Natural Transformation: a way of/for comparing functors"]
     [:div "   - maps Morphism(s) to commuting diagram(s) (naturality squares). i.e."]
     [:div "     comorphism: replacing a square of (complex) relations with a single morphism"]
     [:div "   - picks a morphish between two Objs; Picking 1 morphishm from a homset"]
     [:div "   - Components of NaT"]
     [:div "   - Composing Ftor acting on an Obj with a Ftor acting on a Morphishm: " [e "αb ◦ Ff"]]
     [:div " "]
     [:div "   - Every polymorphic Fn is a NaT: it is defined for every single type"]
     [:div "     i.e. multiplication (Product) of all Objs in a Category. The same goes for"]
     [:div "     the dual - the Sum."]
     [:div "   - Functor is a container, NaT repackages the container"]
     [:div " "]
     [:div "**** Compositons of Natural Transformations"]
     [:div "   See https://math.vanderbilt.edu/dept/conf/tacl2013/coursematerials/SelingerTACL20132.pdf"]
     [:div "   E.g. NaT compositons is scala: https://gist.github.com/Mzk-Levi/752d1e0f2f7f30cd3bda"]
     [:div "   Legend:"]
     [:div "       A - an Obj in the Category C"]
     [:div "       (...)A / [...]A - an A-component of the NaT (...) / [...]"]
     [:div "       αA / βA - an A-component of the NaT α / β"]
     [:div "       αFA - an FA-component of the NaT α"]
     [:div "       βGA / βFA- GA/FA-component of the NaT β"]
     [:div " "]
     [:div "***** Verical Compositon of NaTs:"]
     [:div "     If " [e "α:F → G"] " and " [e "β:G → H"] " are natural transformations, then so is " [e "β • α : F → H"] "."]
     [:div "     Is it defined by:"]
     [:div "         " [e "(β • α)A = βA ◦ αA : FA → HA"]]
     [:div "     A - an Obj in the Category C"]
     [:div "     (...)A - an A-component of the NaT (...)"]
     [:div " "]
     [:div "     - is associative and has an id, and allows one to consider the collection"]
     [:div "       of all functors C → D itself as a category."]
     [:div " "]
     [:div "***** Right Whiskering"]
     [:div "     If F, G : C → D and H : D → E are Ftors, and if α : F → G is a NaT, the right whiskering"]
     [:div "         " [e "H ◦ α : H ◦ F → H ◦ G"]]
     [:div "     is defined as " [e "(H ◦ α)A : H(FA) → H(GA)"] " by " [e "(H ◦ α)A = H(αA)"]]
     [:div " "]
     [:div "***** Left Whiskering"]
     [:div "     If F : C → D and G, H : D → E are Ftors, and if α : G → H is a NaT, the left whiskering"]
     [:div "         " [e "α ◦ F : G ◦ F → H ◦ F"]]
     [:div "     is defined as " [e "(α ◦ F)A : G(FA) → H(FA)"] " by " [e "(α ◦ F)A = αFA"]]
     [:div " "]
     [:div "***** Horizontal Compositon of NaTs:"]
     [:div "     If F, G : C → D and H, K : D → E are Ftors, and if α : F → G and β : H → K"]
     [:div "     are NaTs, the horizontal composition:"]
     [:div "         " [e "β ◦ α : H ◦ F → K ◦ G"]]
     [:div "     can be defined in two different ways:"]
     [:div "     - Right whiskering followed by left whiskering:"]
     [:div "         " [e "β ◦ α = (β ◦ G) • (H ◦ α)"]]
     [:div "     - Left whiskering followed by right whiskering:"]
     [:div "         " [e "β ◦ α = (K ◦ α) • (β ◦ F)"]]
     [:div " "]
     [:div "     The two definitions coincide, because"]
     [:div "         " [e "[(β ◦ G) • (H ◦ α)]A = βGA ◦ H(α A)"] ", and"]
     [:div "         " [e "[(K ◦ α) • (β ◦ F)]A = K(α A) ◦ βFA"]]
     [:div " "]
     [:div "     - is associative with an id, and the id coincides with that for vertical"]
     [:div "       composition."]
     [:div " "]
     [:div " "]
     [:div "*** Yoneda Lemma: [C,Set](C(a,-), F) ⋍ F a   also: [C,Set](C(a,-), C(b,-)) ⋍ C(b,a)"]
     [:div "    - Intuition: NaT and Functor (i.e. Container) can replace each other"]
     [:div "    - Description of integration over a special Ftor (i.e. Hom Functor)"]
     [:div " "]
     [:div "    a - some arbitrary Obj of C"]
     [:div "    F - some arbitrary Ftor acting on the Obj a"]
     [:div "    ⋍ - \"naturally isomorphic\" (i.e. a NaT exists such that its components are"]
     [:div "        all invertible isomorphisms)"]
     [:div " "]
     [:div "    Hom functors - Intuition:"]
     [:div "    - Play some special role in the Category of Ftors"]
     [:div "    - Serve for the same purposes as Free Monoids"]
     [:div " "]
     [:div "    It's enough to define this NaT on one Obj (i.e. set C(a,a)) and moreover"]
     [:div "    it's enough to define it on one Point in this Set i.e. the Identity on Obj a."]
     [:div "    The rest of the NaT is transported from this Point."]
     [:div " "]
     [:div "    (                     ) ⋍ F a"]
     [:div "              ⎜                ⎜"]
     [:div "              ⎜                +-- Container of the Obj a (i.e. the data structure)"]
     [:div "              +------------------- Polymorphic higher order Function"]
     [:div " "]
     [:div "    (∀ x : (a → x) → F x) ⋍ F a"]
     [:div "              ⎜     ⎜   ⎜      ⎜"]
     [:div "              ⎜     ⎜   ⎜      +-- Container of the Obj a (i.e data structure)"]
     [:div "              ⎜     ⎜   +--------- Functor"]
     [:div "              ⎜     +------------- NaT i.e. Polymorphic Higher Order Function"]
     [:div "              +------------------- ..."]
     [:div " "]
     [:div " "]
     [:div "*** Yoneda Embedding https://youtu.be/JH_Ou17_zyU?t=1h8m9s"]
     [:div "    Ideaa: Replace a content of an Obj a (picked i.e. fixed) by a totality of Arrows ending in this Obj. It's content and props."]
     [:div "    Set of Arrow from every possible Obj x to the Obj a"]
     [:div " "]
     [:div "    Mapping from Obj x to the Set of Arrows x→a:"]
     [:div "    1. for every Obj a I get a different Ftor from C to Set,"]
     [:div "    2. then vary the Obj a:"]
     [:div " "]
     [:div "*** Khan Extentions: the next abstraction level"]
     [:div " "]
     [:div "*** Adjunctions: weakening of \"equality\" of Categories"]
     [:div "    \"inverse\" is defined only for functions not functors"]
     [:div "**** e.g. Currying: from a Pair to Function type"]
     [:div "*** Adjointness - constructing / generating principle"]
     [:div "    - Adjunctions/Adjoins are monads ???"]
     [:div "    Adjoin examples:"]
     [:div "    (-) x A (product) ⊣ (-)^A (exponential)"]
     [:div "    '+' (coproduct) ⊣ '∆' (pairing) ⊣ 'x' (product)"]
     [:div "    induction, recursion, Natural Numbers (inductively defined), Lists, ..."]
     [:div "    conjunction, disjunction, True, False, Exponentiation"]
     [:div "    Quantifiers: ∀ Every, ∃ Exists; Σ Sigma, Π Pi"]
     [:div " "]
     [:div "*** Fibre: a buch of points mapped to the same value; invertibility of a function to a fibre"]
     [:div "*** Abstraction: i.e. non-invertibility"]
     [:div "   - from all properties (i.e. all points of a fibre) I'm interested only in one"]
     [:div "   - e.g. I'm not interested in what was the exact input value of a function,"]
     [:div "     I'm interested only if it was an even or odd value"]
     [:div "*** Modeling: mapping / injecting"]
     [:div "*** HomSet: HomC(A,B) = {f: A → B} - set of all morphisms A → B in category C (Objs of C don't need to be sets)"]
     [:div "   External vs. Internal Homset"]
     [:div " "]
     [:div "*** Free Monoid: has an unique mapping to every other monoid"]
     [:div "*** HomFunctor: Functor to category of Sets; has a NaT to every other functor; this NaT is not unique but limited"]
     [:div "   Reader functor in Haskell"]
     [:div "*** Covariant functor: Hom(A,–) : C → Set;"]
     [:div "    G f :: (a → b) → (G a → G b); Same directions in src and dst Category"]
     [:div "    Hom(A,–) maps each object X in C to the set of morphisms, Hom(A, X)"]
     [:div "    Hom(A,–) maps each morphism f : X → Y to the function"]
     [:div "    Hom(A, f) : Hom(A, X) → Hom(A, Y) given by"]
     [:div " "]
     [:div "*** Contravariant functor: Hom(–,B) : C → Set"]
     [:div "    G f :: (a → b) → (G b → G a); Reverse directions in src and dst Category"]
     [:div "    Hom(–,B) maps each object X in C to the set of morphisms, Hom(X, B)"]
     [:div "    Hom(–,B) maps each morphism h : X → Y to the function"]
     [:div "    Hom(h, B) : Hom(Y, B) → Hom(X, B) given by"]
     [:div " "]
     [:div "*** Representable Functor F: C → Set"]
     [:div "   Represents objs of C as sets and functions of C as morphisms between sets."]
     [:div "   i.e. functions \"tabulate\", \"index\" can be created; mapping of function to a data-type"]
     [:div " "]
     [:div "   fix obj A ∈ C there is HomC(A,_): HomC(A, X) → HomC(A, Y) where there is a morphism X → Y"]
     [:div "   e.g.:"]
     [:div "   The forgetful functor Grp → Set on the category of groups (G, *, e) is represented by (Z, 1)."]
     [:div "   The forgetful functor Ring → Set on the category of rings is represented by (Z[x], x), the polynomial ring in one variable with integer coefficients."]
     [:div "   The forgetful functor Vect → Set on the category of real vector spaces is represented by (R, 1)."]
     [:div "   The forgetful functor Top → Set on the category of topological spaces is represented by any singleton topological space with its unique e"]
     [:div "*** Naturality condition: Gf ∘ αa = αb ∘ Ff i.e. the Naturality Square"]
     [:div "*** Homomorphism: structure-preserving mapping between 2 algebraic structures (e.g. monoids, groups, rings, vector spaces)."]
     [:div "    f(m * n) = f(m) * f(n)"]
     [:div " "]
     [:div "    Individual monoids themselves give category"]
     [:div "    Monoids with homomorphisms give category"]
     [:div " "]
     [:div "*** Kleisli category:"]
     [:div "   Monad: return: a → m a; bind: m a → (a → m b) → m b"]
     [:div "     You can operate on IO Monad"]
     [:div "     You can't extract anything from IO Monad (it's lost)"]
     [:div "     Monoind in Category of Endofunctors"]
     [:div "   Comonad: (w a → b) → (w b → c) → (w a → c)"]
     [:div "     You can extract from IO Monad"]
     [:div "     You can't put anything to IO Monad"]
     [:div "*** Topos: a type of a Category being able to be a replacement for Set Theory; provides among other things a notion of a Subse"]
     [:div "*** TODO:"]
     [:div "   - Subobject Classifier etc.: see Bartosz's blog"]
     [:div "   - Sheaf (Garbe, Faisceau, zvazok)- tool for tracking locally defined data"]
     [:div "   - Presheaf: Functor F: Cop → Set"]
     [:div " "]
     [:div "*** Indexed Monad: IxMonad: ibind: m i j a → (a → m j k b) → m i k b"]
     [:div "   state composition"]
     [:div "   Session Types, Dependent Types, Dependent State Types"]
     [:div "*** Curry-Howard-Lambek correspondence: Intuitionistic Logic <→ Type Theory <→ Category Theory:"]
     [:div "  Function A → B is a proof of logical implication A => B"]
     [:div "  Direct relationship between computer programs and mathematical proofs; from 1940-ties"]
     [:div "  Link between Computation and Logic;"]
     [:div "  Proofs-as-programs and propositions- or formulae-as-types interpretation;"]
     [:div "  Proofs (= Programs) can be executed;"]
     [:div "  Typed lambda calculi derived from the Curry–Howard-Lambek paradigm led to software like Coq;"]
     [:div "  Curry-Howard-Lambek correspondence might lead to unification between mathematical logic and foundational computer science;"]
     [:div "  Popular approach: use monads to segregate provably terminating from potentially non-terminating code"]
     [:div " "]
     [:div "    | INTUITIONISTIC (Constructive) LOGIC (Howard)   | TYPE THEORY - Functional Programming (Curry)                         | CATEGORY THEORY (Lambek) |"]
     [:div "    |------------------------------------------------+----------------------------------------------------------------------+--------------------------|"]
     [:div "    | Proposition of some type - (something is true) | Type (contract - a set of values that passes the contract)           |                          |"]
     [:div "    | Proof of some type                             | Term (A program - guarded fn)                                        |                          |"]
     [:div "    | Normalisation (Proof equality)                 | Computation (substitute variable with value)                         |                          |"]
     [:div "    |------------------------------------------------+----------------------------------------------------------------------+--------------------------|"]
     [:div "    | P implies Q: P → Q (i.e. there exists one)    | paricular fn of fn of P-contract to guarded fn of Q-contract: P → Q |                          |"]
     [:div "    | → is constructive implication                 | → is function from-to                                               |                          |"]
     [:div "    | false      → false (implies)                  | {}       →  {}  no values (empty set); contract cannot be satisfied |                          |"]
     [:div "    | false      → true                             | {}       →  {.} (one element set)                                   |                          |"]
     [:div "    | true       → true                             | {.}      →  {.} (identity function)                                 |                          |"]
     [:div "    | true  (not →) false (does not imply)          | {.} (not →) {}                                                      |                          |"]
     [:div " "]
     [:div " "]
     [:div "** Correspondance of type habitation and proposition"]
     [:div "   inhabited - has elems / members"]
     [:div "   \"Either a b\" is inhabited if either a or b is inhabited (at least one of them is true / provable)"]
     [:div " "]
     [:div "   Curry: ((a,b) → c) → (a → (b → c))"]
     [:div "   Uncurry: (a → (b → c)) → ((a,b) → c)"]
     [:div " "]
     [:div "   Eval: a function of two args / a pair"]
     [:div "   \"((a => b), a) → b\" this is modus-ponens in logic \"a => b ∧ a → b\""]
     [:div " "]
     [:div "    | True proposition | False proposition | Conjunction a ∧ b         | Disjunction a ∨ b           | Implication a => b   |"]
     [:div "    | Unit-type        | Void-type         | Pair (a,b)                | Either a b                  | Function type a → b |"]
     [:div "    | sinhabited       | not inhabited     |                           |                             |                      |"]
     [:div "    | Terminal obj     | Initial obj       | Categorical product a × b | Categorical coproduct a ⎥ b | Exponential obj b^a  |"]
     [:div " "]
     [:div " "]
     [:div "    0 - void type - ?"]
     [:div "    1 - unit type - 0th-power: terminal obj"]
     [:div "    2 - bool type (two possible values): 1st-power: the obj itself"]
     [:div "    3 - int type - 2nd-power: product"]
     [:div "    4 - real type (if continuum hypothesis holds :-)"]
     [:div "    5 - ? type"]
     [:div " "]
     [:div "    JavaScript & Category Theory: Category == Contracts + Functions guarded by contracts"]
     [:div " "]
     [:div "** Set vs. Category theory comparision:"]
     [:div "   | Set theory                  | Category theory                                          | JavaScript                     |"]
     [:div "   |-----------------------------+----------------------------------------------------------+--------------------------------|"]
     [:div "   | membership relation         | -                                                        |                                |"]
     [:div "   | elements                    | objects                                                  | contracts                      |"]
     [:div "   | sets                        | categories                                               |                                |"]
     [:div "   | -                           | morphisms (structure-preserving mapping between objects) | functions guarded by contracts |"]
     [:div "   | functions                   | functors  (maps between categories)                      |                                |"]
     [:div "   | equations between elements  | isomorphisms between objects                             |                                |"]
     [:div "   | equations between sets      | equivalences between categories                          |                                |"]
     [:div "   | equations between functions | natural transformations (maps between functors)          |                                |"]
     [:div " "]
     [:div "   Categorification: process of weakening structure, weakening equalities down to natural isomorphisms and then adding-in rules"]
     [:div "   that these natural isomorphisms have to follow (so it behaves well)"]
     [:div "   Counting number of elements in sets is decategorification; from category we get set or from set we get a number"]
     [:div " "]
     [:div "   Monoid homomorphisms: a function between the sets of monoid elements that preserved the monoid structure"]
     [:div "   Monoidal functors:    a functor between categories that preserves the monoidal structure (should preserve multiplication)"]
     [:div "   from functor(prodn([x, y, ..])) to prodn([functor(x), functor(y), ..])"]
     [:div "   Monoidal monad:       ???"]
     [:div " "]
     [:div "   Functor:"]
     [:div "   \"forget the indexing (domain functor)\""]
     [:div " "]
     [:div "*** Contract = Object"]
     [:div "*** Product: examples:"]
     [:div "    Objects   - numbers"]
     [:div "    Morphisms - functions 'less/greater or equal than'"]
     [:div " "]
     [:div "*** Isomorphism (bijection when f is a function on set / sets):"]
     [:div "  ∀ f: X → Y  there ∃ g: Y → X such that g ∘ f = idX and f ∘ g = idY; idX, idY are identity morphisms on X, Y"]
     [:div "  (f is invertible and g is the inverse of f)"]
     [:div " "]
     [:div "** Category theory - Modeling (new vocabulary)"]
     [:div "   | hierarchies                | partial orders     |"]
     [:div "   | symmetries                 | group elements ?   |"]
     [:div "   | data models                | categories         |"]
     [:div "   | agent actions              | monoid actions     |"]
     [:div "   | local-to-global principles | sheaves (lanovica) |"]
     [:div "   | self-similarity            | operads            |"]
     [:div "   | context                    | monads             |"]
     [:div " "]
     [:div " "]
     [:div "** olog = ontology log"]
     [:div "   Different branches of mathematics can be formalized"]
     [:div "   into categories. These categories can then be connected together by functors. And the"]
     [:div "   sense in which these functors provide powerful communication of ideas is that facts and"]
     [:div "   theorems proven in one category can be transferred through a connecting functor to"]
     [:div "   yield proofs of an analogous theorem in another category. A functor is like a conductor"]
     [:div "   of mathematical truth."]
     [:div " "]
     [:div "*** Mappings: X → Y (Zobrazenia):"]
     [:div "    Surjection: all Ys are used;                                     |X| ≥ |Y| (onto; \"at least as big\")"]
     [:div "    Injective:  distinct Xs → distinct Ys;                           |X| ≤ |Y| (? one-to-one ?)"]
     [:div "    Bijection:  exact pairing between X, Y;                          |X| = |Y| (vzajomne jednoznacne zobrazenie, \"same size\")"]
     [:div "    Strict:     Surjection from X to Y but no bijection from Y to X; |X| < |Y| (? double usage of some Ys ?, \"strictly bigger\")"]
     ]}])
