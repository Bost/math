:PROPERTIES:
:ID:       03b37946-8b56-43eb-b714-4124321ae40a
:END:
#+title: Racket

* Resources
  :PROPERTIES:
  :ID:       e538b9e0-6f63-420b-aba1-5815caae4566
  :END:

https://stackoverflow.com/a/54165633
The Scheme standard uses only the term procedure.
In Racket function is a procedure with no side effects.

[[https://racket-news.com/2021/11/racket-news-issue-55.html][Racket News]]

* Command line snippets
  #+BEGIN_SRC sh
  # package management
  raco pkg install <package>
  raco pkg remove <package>

  # how to run a Racket program
  racket program.rkt

  # 'Hello World' from the command line
  racket -e    '(printf "Hello World\n")'
  racket -eval '(printf "Hello World\n")'
  #+END_SRC

* Structures
  #+BEGIN_SRC racket
  ;; structures definition
  (struct structName (item0
                      item1
                      ; ...
                      item-n)
    #:transparent)    ;; instantiation
  (define s (structName 'a 'b 'c))
  ;; accessing fields of the structure instance via the dash '-'
  ;; structName-item1 is the structure accessor
  (structName-item1 s) ;; => 'b
  #+END_SRC

* define vs let
  #+BEGIN_SRC racket
  ;; https://stackoverflow.com/a/5406423
  ;; difference between `define` and `let` is in the scope:
  ;; correct:
  (define (f x)
    (let ((a 1))
      (+ a x)))
  ;; wrong:
  (define (f x)
    (let ((a 1)))
    (+ a x))
  ;; correct:
  (define (g x)
    (define a 1)
    (+ a x))
  #+END_SRC

* Various racket snippets
  #+BEGIN_SRC racket
  ;; pwd; print working directory
  (current-directory)

  ;; difference between `print`, `write` and `display`
  ;; https://docs.racket-lang.org/guide/read-write.html
  (printf "~a as a string is ~s.\n" '(3 4) "(3 4)")

  ;; count
  (length '(1 2 3))
  (hash-count #hash((foo . 41)))
  (hash-count #hasheq((foo . 41)))

  ;; function composition: compose, compose1
  (define (inc n) (+ n 1))
  ((compose str inc length) '(1 2 3))

  ;; info.rkt: collection of dependecies

  ;; show doc in browser using local copy.
  ;; C-c d / M-x racket-doc
  ;; C-c . / M-x racket-describe

  ;; sexp comment #;single-sexp
  ;; block comment #| sexp-1 sexp-2 ... |#

  ;; rhs - right hand side

  ;; namespace alias
  (require (prefix-in my: "file.rkt")) ;; see also `rename-in`
  ;; usage
  (my:function)

  ;; filter list https://stackoverflow.com/a/57814082
  (define lst '(("Ben" 2 "dog") ("Kath" 1 "cat") ("Matt" 6 "dog")))
  (filter (lambda (e) (equal? (caddr e) "dog")) lst)
  ;; => '(("Ben" 2 "dog") ("Matt" 6 "dog"))
#+END_SRC

* Macros: quotes, syntax, etc.
  '     adds quote
  `     adds quasiquote - see notes
  ,     adds unquote
  ,@    adds unquote-splicing
  #'    adds syntax

  quote-syntax - similar to syntax. Unlike syntax (#'), quote-syntax does not
  substitute pattern variables bound by with-syntax, syntax-parse, or syntax-case.

  #`    adds quasisyntax
  #,    adds unsyntax
  #,@   adds unsyntax-splicing
  (quote-syntax (1 2 3))

  #""   byte-string; predicate `bytes?`

  ;; (: v t)     `v` has a type `t`
  ;; (: v : t)   `v` has a type `t`

* REPL
  The `enter!` form both loads the code and switches the evaluation context to
  the inside of the module, just like DrRacketâ€™s Run button.
  #+BEGIN_SRC racket
  (enter "mymodule.rkt")
  #+END_SRC

* Cons and List
  `list` is an abbreviation for a series of `cons`:
  #+BEGIN_SRC racket
  (equal? (list 1 2 3)
          (cons 1 (cons 2 (cons 3 null))))
  #+END_SRC

  #+RESULTS:
  : #t

* Read and evaluate code from string
  #+BEGIN_SRC racket
  (eval (read (open-input-string "(+ 1 2)")))
  ;; or
  (with-input-from-string "(+ 1 2)"
    (lambda () (eval (read))))
  ;; or
  (eval (call-with-input-string "(+ 1 2)" read)) ;; string port is auto-closed
  #+END_SRC

* RacketConf 2021
  - https://racket.discourse.group
  - [[https://github.com/soegaard/remacs][remacs - the Emacs style editor written in Racket]]
  - [[https://youtu.be/73dDj_z66qo?t=3578][Matthias Felleisen - Every language has a slogan]]

