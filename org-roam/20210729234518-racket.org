:PROPERTIES:
:ID:       03b37946-8b56-43eb-b714-4124321ae40a
:END:
#+title: Racket

* Resources
  :PROPERTIES:
  :ID:       e538b9e0-6f63-420b-aba1-5815caae4566
  :END:

* Command line snippets
  #+BEGIN_SRC bash :results output
  # package management
  raco pkg install <package>
  raco pkg remove <package>

  # how to run a Racket program
  racket program.rkt

  # 'Hello World' from the command line
  racket -e    '(printf "Hello World\n")'
  racket -eval '(printf "Hello World\n")'
  #+END_SRC

* Structures
  #+BEGIN_SRC racket
  ;; structures definition
  (struct structName (item0
                      item1
                      ; ...
                      item-n)
    #:transparent)    ;; instantiation
  (define s (structName 'a 'b 'c))
  ;; accessing fields of the structure instance via the dash '-'
  ;; structName-item1 is the structure accessor
  (structName-item1 s) ;; => 'b
  #+END_SRC

* define vs let
  #+BEGIN_SRC racket
  ;; https://stackoverflow.com/a/5406423
  ;; difference between `define` and `let` is in the scope:
  ;; correct:
  (define (f x)
    (let ((a 1))
      (+ a x)))
  ;; wrong:
  (define (f x)
    (let ((a 1)))
    (+ a x))
  ;; correct:
  (define (g x)
    (define a 1)
    (+ a x))
  #+END_SRC

* Various racket snippets
  #+BEGIN_SRC racket
  ;; pwd; print working directory
  (current-directory)

  ;; difference between `print`, `write` and `display`
  ;; https://docs.racket-lang.org/guide/read-write.html
  (printf "~a as a string is ~s.\n" '(3 4) "(3 4)")

  ;; count
  (length '(1 2 3))
  (hash-count #hash((foo . 41)))
  (hash-count #hasheq((foo . 41)))

  ;; (: flexible-length (-> (U String (Listof Any)) Integer))
  (define (flexible-length str-or-lst)
  (if (string? str-or-lst)
      (string-length str-or-lst)
      (length str-or-lst)))

  ;; function composition: compose, compose1
  (define (inc n) (+ n 1))
  ((compose str inc length) '(1 2 3))

  ;; info.rkt: collection of dependecies

  ;; show doc in browser using local copy.
  ;; C-c d / M-x racket-doc
  ;; C-c . / M-x racket-describe

  ;; sexp comment #;single-sexp
  ;; block comment #| sexp-1 sexp-2 ... |#

  ;; rhs - right hand side

  ;; namespace alias
  (require (prefix-in my: "file.rkt")) ;; see also `rename-in`
  ;; usage
  (my:function)

  ;; filter list https://stackoverflow.com/a/57814082
  (define lst '(("Ben" 2 "dog") ("Kath" 1 "cat") ("Matt" 6 "dog")))
  (filter (lambda (e) (equal? (caddr e) "dog")) lst)
  ;; => '(("Ben" 2 "dog") ("Matt" 6 "dog"))

  (map string? '(1 "a" 3))  ;; => '(#f #t #f)

  (andmap number? '(1 2 3)) ;; => #t
#+END_SRC

* Macros: quotes, syntax, etc.
  #+BEGIN_SRC racket
  (quote-syntax (1 2 3))
  #+END_SRC

  quote-syntax - similar to syntax. Unlike syntax (#'), quote-syntax does not
  substitute pattern variables bound by with-syntax, syntax-parse, or syntax-case.

  | '   | quote                  |
  | `   | quasiquote - see notes |
  | ,   | unquote                |
  | ,@  | unquote-splicing       |
  | #'  | syntax                 |
  | #`  | quasisyntax            |
  | #,  | unsyntax               |
  | #,@ | unsyntax-splicing      |

  | #""       | byte-string; predicate `bytes?` |
  | (: v t)   | `v` has a type `t`              |
  | (: v : t) | `v` has a type `t`              |

* REPL
  The `enter!` form both loads the code and switches the evaluation context to
  the inside of the module, just like DrRacketâ€™s Run button.
  #+BEGIN_SRC racket
  (enter "mymodule.rkt")
  #+END_SRC

* Cons and List
  `list` is an abbreviation for a series of `cons`:
  #+BEGIN_SRC racket
  (equal? (list 1 2 3)
          (cons 1 (cons 2 (cons 3 null))))
  #+END_SRC

* Read and evaluate code from string
  #+BEGIN_SRC racket
  (eval (read (open-input-string "(+ 1 2)")))
  ;; or
  (with-input-from-string "(+ 1 2)"
    (lambda () (eval (read))))
  ;; or
  (eval (call-with-input-string "(+ 1 2)" read)) ;; string port is auto-closed
  #+END_SRC

* RacketConf 2021
  - https://racket.discourse.group
  - [[https://github.com/soegaard/remacs][remacs - the Emacs style editor written in Racket]]
  - [[https://youtu.be/73dDj_z66qo?t=3578][Matthias Felleisen - Every language has a slogan]]

* Empty string predicate
See [[https://rosettacode.org/][Rosetta Code]]
#+BEGIN_SRC racket
(define empty-string "")
(define (string-null? s) (string=? "" s))
(define (string-not-null? s) (string<? "" s))
#+END_SRC

* Hunt the Wumpus
[[https://en.wikipedia.org/wiki/Hunt_the_Wumpus][Wikipedia: Hunt the Wumpus]]
[[https://rosettacode.org/wiki/Hunt_the_Wumpus#Racket][Racket: Hunt the Wumpus]]

* Heresy
The Heresy Programming Language https://github.com/jarcane/heresy

The Heresy language is a functional Lisp/Scheme dialect implemented in Racket,
with syntax inspired by the BASIC family of programming languages. Its principle
goals are to provide a simple core language for BASIC and other programmers to
experiment with and learn how to program functionally. This document will detail
the general philosophy of the Heresy language, such as exists, as well as the
language syntax and functions.
