:PROPERTIES:
:ID:       03b37946-8b56-43eb-b714-4124321ae40a
:END:
#+title: Racket

* Resources
  :PROPERTIES:
  :ID:       e538b9e0-6f63-420b-aba1-5815caae4566
  :END:

* Command line snippets
  #+BEGIN_SRC bash :results output
  # package management
  raco pkg install <package>
  raco pkg remove <package>

  # how to run a Racket program
  racket program.rkt

  # 'Hello World' from the command line
  racket -e    '(printf "Hello World\n")'
  racket -eval '(printf "Hello World\n")'
  #+END_SRC

* Structures
  #+BEGIN_SRC racket
  ;; structures definition
  (struct structName (item0
                      item1
                      ; ...
                      item-n)
    #:transparent)    ;; instantiation
  (define s (structName 'a 'b 'c))
  ;; accessing fields of the structure instance via the dash '-'
  ;; structName-item1 is the structure accessor
  (structName-item1 s) ;; => 'b
  #+END_SRC

* define vs let
  #+BEGIN_SRC racket
  ;; https://stackoverflow.com/a/5406423
  ;; difference between `define` and `let` is in the scope:
  ;; correct:
  (define (f x)
    (let ((a 1))
      (+ a x)))
  ;; wrong:
  (define (f x)
    (let ((a 1)))
    (+ a x))
  ;; correct:
  (define (g x)
    (define a 1)
    (+ a x))
  #+END_SRC

* Various racket snippets
  #+BEGIN_SRC racket
  ;; pwd; print working directory
  (current-directory)

  ;; difference between `print`, `write` and `display`
  ;; https://docs.racket-lang.org/guide/read-write.html
  (printf "~a as a string is ~s.\n" '(3 4) "(3 4)")

  ;; count
  (length '(1 2 3))
  (hash-count #hash((foo . 41)))
  (hash-count #hasheq((foo . 41)))

  ;; (: flexible-length (-> (U String (Listof Any)) Integer))
  (define (flexible-length str-or-lst)
  (if (string? str-or-lst)
      (string-length str-or-lst)
      (length str-or-lst)))

  ;; function composition: compose, compose1
  (define (inc n) (+ n 1))
  ((compose str inc length) '(1 2 3))

  ;; info.rkt: collection of dependecies

  ;; show doc in browser using local copy.
  ;; C-c d / M-x racket-doc
  ;; C-c . / M-x racket-describe

  ;; sexp comment #;single-sexp
  ;; block comment #| sexp-1 sexp-2 ... |#

  ;; rhs - right hand side

  ;; namespace alias
  (require (prefix-in my: "file.rkt")) ;; see also `rename-in`
  ;; usage
  (my:function)

  ;; filter list https://stackoverflow.com/a/57814082
  (define lst '(("Ben" 2 "dog") ("Kath" 1 "cat") ("Matt" 6 "dog")))
  (filter (lambda (e) (equal? (caddr e) "dog")) lst)
  ;; => '(("Ben" 2 "dog") ("Matt" 6 "dog"))

  (map string? '(1 "a" 3))  ;; => '(#f #t #f)

  (andmap number? '(1 2 3)) ;; => #t
  #+END_SRC

* Macros: quotes, syntax, etc.
  #+BEGIN_SRC racket
  (quote-syntax (1 2 3))
  #+END_SRC
  quote-syntax - similar to syntax. Unlike syntax (#'), quote-syntax does not
  substitute pattern variables bound by with-syntax, syntax-parse, or syntax-case.
  | '   | quote                  |
  | `   | quasiquote - see notes |
  | ,   | unquote                |
  | ,@  | unquote-splicing       |
  | #'  | syntax                 |
  | #`  | quasisyntax            |
  | #,  | unsyntax               |
  | #,@ | unsyntax-splicing      |

  Other
  | #""       | byte-string; predicate `bytes?` |
  | (: v t)   | `v` has a type `t`              |
  | (: v : t) | `v` has a type `t`              |

* REPL
  The `enter!` form both loads the code and switches the evaluation context to
  the inside of the module, just like DrRacketâ€™s Run button.
  #+BEGIN_SRC racket
  (enter "mymodule.rkt")
  #+END_SRC

* Cons and List
  `list` is an abbreviation for a series of `cons`:
  #+BEGIN_SRC racket
  (equal? (list 1 2 3)
          (cons 1 (cons 2 (cons 3 null))))
  #+END_SRC

* Read and evaluate code from string
  #+BEGIN_SRC racket
  (eval (read (open-input-string "(+ 1 2)")))
  ;; or
  (with-input-from-string "(+ 1 2)"
    (lambda () (eval (read))))
  ;; or
  (eval (call-with-input-string "(+ 1 2)" read)) ;; string port is auto-closed
  #+END_SRC

* Empty string predicate
  See [[https://rosettacode.org/][Rosetta Code]]
  #+BEGIN_SRC racket
  (define empty-string "")
  (define (string-null? s) (string=? "" s))
  (define (string-not-null? s) (string<? "" s))
  #+END_SRC

* Converting Values to Strings
  [[https://docs.racket-lang.org/reference/strings.html#%28part._format%29][Converting Values to Strings]]
  #+BEGIN_SRC racket
  (require racket/format)
  (~a "Hi" 1 2 'People)                 ; => "Hi12People"
  (~a "Hi" 1 2 'People '(Around))       ; => "Hi12People(Around)"
  (~a #:separator "-" "Hi" 1 2 'People) ; => "Hi-1-2-People"
  ;; See
  ;; ~a ~v ~s ~e ~r ~.a ~.v ~.s
  #+END_SRC
