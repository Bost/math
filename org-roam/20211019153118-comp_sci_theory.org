:PROPERTIES:
:ID:       800cb5b7-6af4-4114-9e56-24c148931b52
:END:
#+title: Comp-Sci Theory

# generate pdf: M-x org-latex-export-to-pdf

#+LATEX_HEADER: \usepackage{cat-7-sketches}
# #+LATEX_HEADER: \usepackage{foo}

# https://en.wikipedia.org/wiki/List_of_mathematical_symbols_by_subject
# latexpreview / nolatexpreview C-c C-x C-l
# #+STARTUP: nolatexpreview
#+STARTUP: showeverything inlineimages nolatexpreview

* Complexity classes & Complexity Zoo
  [[https://complexityzoo.uwaterloo.ca/Complexity_Zoo][Complexity Zoo]]
  NP      - decision problems solvable by non-deterministic TM (Turing Machine) in polynomial time
  PSPACE  - decision problems solvable by     deterministic TM                  in polynomial space
** computational problem type: e.g. problems: decision, function, counting, optimization, promise, etc.
** model of computational: e.g. deterministic TM (Turing Machine), non-deterministic TM, boolean circuits, quantum TM, monotone circuits
** bounded resource(s): e.g. space, time
** bounds: e.g. polynomial time, logarithmic space, constant depth

* Unary languages
* Sparse languages
* Untyped Pi π-Calculus
Business Process Modeling

* Untyped Lambda λ-Calculus
  I.e. Formal calculus for manipulating functions; Turing-complete (can simulate any Turing machine)
  e ::= x | λx.e | e e'
  e        - λ-term; expression of a λ-calculus; e.g. e, e', f, g, h are λ-terms
  x        - variable; e.g. x, y, z
  e e'     - left associative application of expression e to expression e'; e.g. M N L = ((M N)L)
  λx.e     - function abstractions of x over e; abstract away the details of expression e
  Currying: Partial function application; Fixing some function parameters
  Application takes precedence over abstraction e.g. λx.M N = λx.(M N)
  Successive abstraction λxy.e = λx.(λy.e)
  Variable occurences in a λ-term; Free / Bounded / Binding
  TODO what is a normal form of a λ-term
** TODO Positive properties of an Untyped λ-Calculus
*** Turing-complete
** Negative properties of an Untyped λ-Calculus
   - Self applications are allowed
   - Existence of normal forms for λ-terms is not guaranteed; this may result in
     undesired infinite calculations
   - Each λ-term has a fixed point. However some important functions e.g.:
    g(n) = 2^n
    succ(n) = n + 1
   don't have a fixed point and cannot belong an Untyped λ-Calculus

* Simply Typed Lambda λ-Calculus: λ->
  Keeps the positive and remove the negative points on Untyped λ-Calculus:
*** No more self application
*** No infinite reduction sequencies (i.e. calculations)
*** Not every simply typed function needs to have a fixed point.
  Drawback: the λ-> is much too weak to encapsulate every computable function
  and hence it's not usable for the formalization of math.

  Contains simple (basic) and funtion types
  e ::= x:τ | (λ(x:σ).(e:τ)):(σ->τ) | e:τ e':τ | c:τ
  e:τ                   - λ-term; expression of a simply typed λ-calculus; e.g. e:τ, e':τ, f:τ, g:τ, h:τ are simply typed λ-terms
  x:τ                   - type variable of the simple type τ; e.g. x:τ, y:τ, z:τ
  e:τ e':τ              - left associative application of expression e:τ to expression e':τ; e.g. e:τ f:τ g:τ = ((e:τ f:τ)g:τ)
  (λ(x:σ).(e:τ)):(σ->τ) - function abstractions of an function with function type σ->τ; abstract away the details of the expression e:τ and declare the abstraction to be of the function type σ->τ
  c:τ                   - ? constant ?
  TODO simple type

* Damas-Hindley-Milner Calculus
  e ::= x | λx.e | e e' | let x = e in e'
  W Algorithm - for type inference: W(Γ,e) = (S,τ)
  Γ - typing env
  S - state
  τ - type

* Hindley-Milner type system - type inference
* Alpha α-conversion / α-equivalence of terms: Term are same up to a renaming of binding and bound vars
* Beta β-reduction (computational): Substitute var x with s in term t: (λx.t)s = [s/x]t
  β- reduction in computation a.k. calculation rule: Simplify proofs by replacing formal params with terms.
  fst<g , h > = g
  snd<g , h > = h
  (λx.h)g = [g/x]h      - substitute variable x in the expression (i.e λ-term) h by the (i.e λ-term) g
  (λx.f)x = [x/x]f = f  - ? do nothing, i.e. void substitution ?
** Fixed Point Theorem: for each λ-term L there exists a λ-term M (a.k.a fixed point) such that LM =β M
   =β   - β-conversion a.k.a β-equality
* TODO Eta η-extentionality principle

* Tautology - "this is always true"

* Type Theory: Extention of lambda calculus with explicit types
** ITT Inentional Type Theory
** OTT Observational Type Theory
Type of a Variable - a set(?) of possible values of that type
? From context Gamma a M can be derrived such that x:A.B ?
Context $\Gamma, x:A, y:Bx$ (e.g. $x$ be a number with property $Bx$, $y$ is a variable for the proof of type $Bx$)
What's the point of having a number? Well we can count up to that number.
Depandent type theory is the master theory of all programming languages. If you understand dependent type theory then you understand everything (every programming language)
Maybe Type: A or B (e.g. A or Fail, A or AirMessage)
** Homotopy Type Theory: ? Equivalence ?

* Axiom of Choice - see "Type Theory Foundations, Lecture 3-wJLTE8rnqH0.mp4"
"the greatest intelectual achievement???"
Predicate = vyrok = tvrdenie
Proposition = ???
(Banach Tarsky Paradox: Slice up an object with a volume into parts with no
volume, and by putting it together get 2 same objects - "create an object for
free")

* Haskell / Agda comparison:
|             | Haskell                              | Agda                                     |
|-------------|--------------------------------------|------------------------------------------|
|             |                                      | full higher order logic with existential |
|             |                                      | and universal quantification             |
|-------------|--------------------------------------|------------------------------------------|
| Type system | Unsound                              | sound                                    |
|             | (arbitrary properties can be prooven |                                          |
|             | i.e. every single type is inhabited) |                                          |
|             | (loop : A, loop = loop)              |                                          |
|-------------|--------------------------------------|------------------------------------------|
|             |                                      | ? Always terminates ?                    |

* Modus Pones: applications of a function to an argument: Agda, Coq, Isabelle
** MP naturally generalizes to instationation of universal quantifiers

* Goedel's Incompleteness Theorem:
Every principle is either (A) too restrictive or (leaves out a good programm) or
(B) not restrictive enough (allows some bad programs)
* Full employment Theorem
Take (A) and search for a new class to add in order to improve the language
without allowing bad programs.
* Theory of Reflexive Domain 1:21 Video 2
* Impossibility of a perfect type-checker for a programming language
It it’s impossible to have a procedure that figures out whether an arbitrary
program halts, it’s easy to show that it’s impossible to have a procedure that
is a perfect recognizer for any overall run time property. A program that
type-checks is guaranteed not to cause a run-time type-error. But since it’s
impossible to recognize perfectly when programs won’t cause type-errors, it
follows that the type-checker must be rejecting programs that really wouldn’t
cause a type-error. The conclusion is that no type-checker is perfect—you can
always do better!

* Krakatoa and Jessie: verification tools for Java and C programs
Why3: platform for deductive program verification
git clone https://scm.gforge.inria.fr/anonscm/git/why3/why3.git

A user can write WhyML programs directly and get correct-by-construction OCaml
programs through an automated extraction mechanism

* The trinity of Philosophy, Computer Science and Mathematics
- Philosophy       : Logic & Proof Theory
- Computer Science : Type Theory
- Mathematics      : Category Theory

* Proof Theory: Proof of soundness, proof of completeness
* PT 1 - Judgements & Propositions
** judgement (obj of knowledge); judgemens are made about propositions
'A is true', 'A is false', M : A - M is a proof of A i.e. M is a program which has a type of A
'A' - proposition
'true' - judgement on a proposition
experiment, observation
sampling, counter examples
judge, jury, religion, boss, conviction "No bugs in my code!"
"I don't see why not": psycho (the oposing party must find argument)
A mathematical proof:
  - an argument that convinces other mathematicians :)
  - verification of a proposition by a chain of logical deductions from a set of axioms
  - deduction from hypotheses to conclusion in which each step is justified by one of a finite list of rules of inference
    https://home.sandiego.edu/~shulman/papers/rabbithole.pdf
Proposition is a statement: can be true or false
Predicate is a proposition: truth depends on the values of variable(s)
Verificationist: The meaning of a connective is given by it's introduction rule(s)
'A and B' is true; A & B : true
** Local soundness of the elimination rules: elim. rules are not too strong
   - no information is gained by applying and eliminating a particular rule
** Local completeness: elim. rules not too weak
** LOcal expantion: witness for the completeness of the rules

* PT 2 - Computational Interpretation: Curry Howard Isomorphism
- Capturing generic notion of effect: functional programming monad from logical point of view
- Computational interpretations of monad come out of logical considerations
- Quote & Eval (not presented in the lecture)
Lax proposition: 'there is something weaker then truth'; 'Possible truth'; It
may or may not be true (in case of non-terminating computation or it might
terminate with some other effects on the way)
◯ A : true  A - proposition, ◯ - 'circle'; 'A is true in the lax sense'; Monad A
Monad - when interacting with real world a failure is always one of the eventualities
      - monad laws are proof-equalities
* PT 3 - Proof Search & Sequent Calculus

* Chomsky hierarchy of formal grammars
  | Grammar | Languages              | Automaton                                       | Production rules (constraints)* | Examples[3]                                                     |
  | Type-0  | Recursively enumerable | Turing machine                                  | α A β -> β                      | L = {w \vertical-line w describes a terminating Turing machine} |
  | Type-1  | Context-sensitive      | Linear-bounded non-deterministic Turing machine | α A β -> α γ β                  | L = {a^n b^n c^n \vertical-line n > 0}                          |
  | Type-2  | Context-free           | Non-deterministic pushdown automaton            | A -> α                          | L = {a^n b^n \vertical-line n > 0}                              |
  | Type-3  | Regular                | Finite state automaton                          | A -> a and A -> a B             | L = {a^n \vertical-line n >= 0}                                 |
** Meaning of symbols:
a = terminal
A, B = non-terminal
α, β, γ = string of terminals and/or non-terminals
α, β = maybe empty
γ = never empty

* Indirect left recursion
[[https://en.wikipedia.org/wiki/Left_recursion][Wikipedia: Left Recursion]]
Occurs when the definition of LR is satisfied via several substitutions. It
entails a set of rules following the pattern:

  | A0 -> β0 A1 α |
  | A1 -> β1 A2 α |
  | An -> βn A0 α |

where [e "β0,β1, ... ,βn"] are sequences that can each yield the empty string,
while [e "α0,α1, ... ,αn"] may be any sequences of terminal and nonterminal
symbols at all. Note that these sequences may be empty. The derivation
[e "A0 => β0 A1 α0 =>^+ A1 α0 =>^+ β1 A2 α1 α0 =>^+ ... =>^+ A0 αn ... α1 α0"]
then gives A0 as leftmost in its final sentential form.

* Normal Forms of Formulas
** DNF - Disjunctive Normal Form / Formula e.g. (A ∧ ¬B ∧ C) ∨ (¬D ∧ E ∧ F)
** CNF - Conjunctive Normal Form / Formula e.g. (A ∨ ¬B ∨ C) ∧ (¬D ∨ E ∧ F)

* Homoiconicity
LISP programs are represented as LISP structures.

Emacs Lisp form can be represented by a data structure called an s-expression
that prints out the same as the form.

"five times the sum of seven and three" can be written as a s-expression with
prefix notation. In Lisp, the s-expression might look like (* 5 (+ 7 3))

s-expression / sexpr or sexp - symbolic expression is:
1. an atom, or
2. an expression of the form (x . y) where x and y are s-expressions.

* Quasiquote
More general mechanism than quote for creating nested list structure without
using constructors explicitly

* Variable scope within a certain function
** static / lexical
scope of a variable v is the program block (e.g. a function): within that block,
the variable name exists, and is bound to the variable's value, but outside that
block, the variable name does not exist.

** dynamic
scope of a variable v is the time-period during which the program block (e.g. a
function) is executing: while the function is running, the variable name exists,
and is bound to its value, but after the function returns, the variable name
does not exist.

* Fixed-point combinator / Y-combinator
"implement recursion in a language without recursion"
[[https://youtu.be/9T8A89jgeTI][Essentials: Functional Programming's Y Combinator - Computerphile]]

[[https://en.wikipedia.org/wiki/Fixed-point_combinator#Fixed-point_combinators_in_lambda_calculus][Fixed-point combinators in lambda calculus]]
Definition:
Y = λf.(λx.f(x x) λx.f(x x))

Y g = (λf.(λx.f(x x) λx.f(x x)))g   (by definition of Y)
    = (λx.g(x x) λx.g(x x))         (by β-reduction of λf: applied Y to g)
    = g(λx.g(x x) λx.g(x x))        (by β-reduction of λx: applied left function to right function)
    = g(Y g)                        (by second equality)
    = g(g(Y g))
    = g(g(g(Y g))
    = g(...(g(Y g)...)

[[https://youtu.be/9T8A89jgeTI?t=217][YouTube: Encoding of Boolean values]]
One is opposite of the other:
TRUE  = λx.λy.x
FALSE = λx.λy.y

TODO [[https://en.wikipedia.org/wiki/SKI_combinator_calculus][Wikipedia: SKI combinator calculus]]
[[https://bartoszmilewski.com/2020/09/06/the-fall-of-the-ski-civilization/][Bartosz Milewski: The Fall of the SKI Civilization]]

* Self-balancing binary search trees
O(log n) {\displaystyle {\text{O}}(\log n)} {\displaystyle {\text{O}}(\log n)}
for basic operations
- AVL-Tree (Adelson-Velsky-Landis)
- RB-Tree (Red-Black) [[https://en.wikipedia.org/wiki/Red%E2%80%93black_tree][Wikipedia: Red-Black Tree]]

* Endophora - Linguistics
  [[https://en.wikipedia.org/wiki/Endophora][Wikipedia: Endophora]]
** Subcategories of Endophoras: φέρω (phérō, "I carry")
*** Anaphora "carrying back" ἀνά (aná, "up")
    [[https://en.wikipedia.org/wiki/Anaphora_(linguistics)][Wikipedia: Anaphora (linguistics)]]
    - Usage of an expression that depends upon an antecedent (previous)
      expression.
    - "Sally arrived, but nobody saw her" - 'her' is an anaphor (= anaphoric
      term)
*** Cataphora "carrying forward" κατά (kata, "downwards")
    [[https://en.wikipedia.org/wiki/Cataphora][Wikipedia: Cataphora]]
    - Usage of an expression that depends upon a postcedent (later) expression.
    - "If you want some, there are cookies in the kitchen" - 'some' is a
      cataphor (= cataphoric expression)
*** Self-reference
    [[https://en.wikipedia.org/wiki/Self-reference][Wikipedia: Self-reference]]

* Anaphoric Macro
  [[https://en.wikipedia.org/wiki/Anaphoric_macro][Wikipedia: Anaphoric Macro]]
  - captures some form supplied to the macro which may be referred to by an
    anaphor (i.e. expression that depends on a previous expression)

  - Example (ANSI Common Lisp; works also in sbcl - Steel Bank Common Lisp ):
    Sum the value of non-nil elements, where 'it' refers to the values of
    elements that do not equal nil:
    #+BEGIN_SRC lisp
    (loop for element in '(nil 1 nil 2 nil nil 3 4 6)
          when element sum it)
    ;; ⇒ 16
    #+END_SRC

    #+BEGIN_SRC lisp
    (defmacro aif (test-form then-form &optional else-form)
      `(let ((it ,test-form))
             (if it ,then-form ,else-form)))

    (aif (+ 2 7)
      (format nil "~A does not equal NIL." it)
      (format nil "~A does equal NIL." it))
    #+END_SRC

* Method Chaining
  #+BEGIN_SRC javascript
  somethings
    .filter(x => x.count > 10)
    .sort((a, b) => a.count - b.count)
    .map(x => x.name)
  #+END_SRC

* Typing
  Gradual Typing, Occurrence Typing

* Semantics
** Denotational Semantics
** Operational Semantics
  https://en.wikipedia.org/wiki/Operational_semantics

  formal programming language semantics

  correctness, safety, security, etc. are verified by constructing proofs from
  logical statements about its execution and procedures, rather than by
  attaching mathematical meanings to its terms (denotational semantics).
