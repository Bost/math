* Lambda Calculus: formal calculus for manipulating functions
  Currying: Partial function application; Fixing some function parameters
  e ::= x | λx.e | e e'
        |    |      |
        |    |      +---- application
        |    +----------- function abstractions
        +---------------- variable

* Typed Lambda Calculus
  e ::= x | λx.e : τ | e e' | c

* Damas-Hindley-Milner Calculus 
  e ::= x | λx.e | e e' | let x = e in e'
  W Algorithm - for type inference: W(Γ,e) = (S,τ)
  Γ - typing env
  S - state
  τ - type

* Math Structures:
** Monoid (M, *, e); Also a Category 'many' morphisms and 'few' (only one) object M
  (like Group withouth inverse elements)
  M - non-empty set
  * - associative operation: (x * y) * z = x * (y * z)
  e - neutral element of M (identity)

** Group (G, *, e): One set G of elements with a 'multiplication' operation (formalization of symetry concept)
  like Monoid; plus every element has its inverse: x-inverse (dual obj): x * x-inverse = x-inverse * x = e
  (i.e. a Category with one object; every morphism is an isomorphism)
  closure: a and b and a*b must be membembers of the same group
  commutativity is not a part of the group definition: x * y = y * x
** Cyclic Group: generated by one element.
** Semigroup: A set with an associative binary operation: x * y
   generalizes a group by preserving only associativity and closure under the binary operation from the axioms defining a group
** Ring (M, +, *) - Okruh
** PreOrder (A, ≤)
   A - nonempty set
   ≤ - pre-ordering relation: must be
                   - reflexive: a ≤ a
                   - transitive: a ≤ b and b ≤ c then a ≤ c

** PoSet - Partialy Ordered Set (A, ≤); Also a Category with 'few' (only one) morphisms between any two objects and many objects
   A - no-nempty set
   ≤ - relation: must be
                   - reflexive: a ≤ a
                   - transitive: a ≤ b and b ≤ c then a ≤ c
                   - aymetric: a ≤ b and b ≤ a then a = b
** TODO Pointed Set
** TODO Pointed Function
** TODO Top (Topological Space)
** eval, exponent in Category Theory

* Tautology - "this is always true"
* Beta β reduction (computational) / Eta η extentionality principle
  β reduction in computation: Simplify proofs by replacing formal params with terms.

  fst<Alpha, Beta> = Alpha
  snd<Alpha, Beta> = Beta
  (lambda x.Beta)Alpha = [Alpha/x]Beta
  (lambda x.f)x = f

* Type Theory: Extention of lambda calculus with explicit types
** ITT Inentional Type Theory
** OTT Observational Type Theory
   Type of a Variable - a set(?) of possible values of that type
   From context Gamma a M can be derrived such that x:A.B
   Context Gamma, x:A, y:Bx (e.g. x be a number with property Bx, y is a variable for the proof of type Bx)
   What's the point of having a number? Well we can count up to that number.
   Depandent type theory is the master theory of all programming languages. If you understand dependent type theory then you understand everything (every programming language)

   Maybe Type: A or B (e.g. A or Fail, A or AirMessage)

** Homotopy Type Theory: ? Equivalence ?
* Axiom of Choice - see "Type Theory Foundations, Lecture 3-wJLTE8rnqH0.mp4"
"the greatest intelectual achievement???"

Predicate = vyrok = tvrdenie
Proposition = ???

(Banach Tarsky Paradox: Slice up an object with a volume into parts with no volume, and by putting it together get 2 same objects - "create an object for free")

* Haskell / Agda comparison:

|             | Haskell                              | Agda                                     |
|-------------+--------------------------------------+------------------------------------------|
|             |                                      | full higher order logic with existential |
|             |                                      | and universal quantification             |
|-------------+--------------------------------------+------------------------------------------|
| Type system | Unsound                              | sound                                    |
|             | (arbitrary properties can be prooven |                                          |
|             | i.e. every single type is inhabited) |                                          |
|             | (loop : A, loop = loop)              |                                          |
|-------------+--------------------------------------+------------------------------------------|
|             |                                      | ? Always terminates ?                    |

* Modus Pones: applications of a function to an argument: Agda, Coq, Isabelle
** MP naturally generalizes to instationation of universal quantifiers
* Goedel's Incompleteness Theorem:
 Every principle is either (A) too restrictive or (leaves out a good programm) or (B) not restrictive enough (allows some bad programs)
* Full employment Theorem: take (A) and search for a new class to add in order to improve the language withouth allowing bad programs.
* Clojure:
** Namespace is a Type
   Namespace contains fns returning values of the same Type. I.e. it is a set of Proofs of a given Proposition (i.e. of a given Type).
** Use morphism from "complicated" Types (i.e. Products consisting of many Types. E.g. maps each having many keys) to subsets of (if possible natural) numbers.
   These subsets should be in fact monads

   inl(...) - injection to the left
   inr(...) - injection to the right

   (A * B) and (A + B) could be seen as a product (e.g. join) and coproduct (e.g. disjoint union) of A and B

* Theory of Reflexive Domain 1:21 Video 2
* Impossibility of a perfect type-checker for a programming language
  It it’s impossible to have a procedure that figures out whether an arbitrary
  program halts, it’s easy to show that it’s impossible to have a procedure that
  is a perfect recognizer for any overall run time property.

  A program that type-checks is guaranteed not to cause a run-time type-error.
  But since it’s impossible to recognize perfectly when programs won’t cause
  type-errors, it follows that the type-checker must be rejecting programs that
  really wouldn’t cause a type-error. The conclusion is that no type-checker is
  perfect—you can always do better!
* Krakatoa and Jessie: verification tools for Java and C programs
  Why3: platform for deductive program verification
  git clone https://scm.gforge.inria.fr/anonscm/git/why3/why3.git
  A user can write WhyML programs directly and get correct-by-construction OCaml programs through an automated extraction mechanism



* Trinity 1. Logic & Proof Theory: Philosophy; 2. Type Theory: Computer Science; 3. Category Theory: Mathematics
* Proof Theory: Proof of soundness, proof of completeness
* PT 1 - Judgements & Propositions 
** judgement (obj of knowledge); judgemens are made about propositions
   'A is true', 'A is false', M : A - M is a proof of A i.e. M is a program which has a type of A
   'A' - proposition
   'true' - judgement on a proposition

  experiment, observation
  sampling, counter examples
  judge, jury, religion, boss, conviction "No bugs in my code!"
  "I don't see why not": psycho (the oposing party must find argument)

  A mathematical proof is a verification of a proposition by a chain of logical deductions from a set of axioms

  Proposition is a statement: can be true or false
  Predicate is a proposition: truth depends on the values of variable(s)

  Verificationist: The meaning of a connective is given by it's introduction rule(s)
  'A and B' is true; A & B : true

** Local soundness of the elimination rules: elim. rules are not too strong
   - no information is gained by applying and eliminating a particular rule
** Local completeness: elim. rules not too weak
** LOcal expantion: witness for the completeness of the rules
* PT 2 - Computational Interpretation: Curry Howard Isomorphism
  - Capturing generic notion of effect: functional programming monad from logical point of view
  - Computational interpretations of monad come out of logical considerations
  - Quote & Eval (not presented in the lecture)

  Lax proposition: 'there is something weaker then truth'; 'Possible truth'; It
  may or may not be true (in case of non-terminating computation or it might
  terminate with some other effects on the way)

  ◯ A : true  A - proposition, ◯ - 'circle'; 'A is true in the lax sense'; Monad A
  Monad - when interacting with real world a failure is always one of the eventualities
        - monad laws are proof-equalities
* PT 3 - Proof Search & Sequent Calculus
